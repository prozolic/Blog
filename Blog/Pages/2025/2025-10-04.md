---
title: .NET10の配列インターフェイス メソッドの非仮想化について
url: /20251004
categories: .NET, .NET10, Performance
$namespace: Blog.Pages
$inherit: PostComponent
---

.NET 10 RC1が2025年9月9日にリリースされました。
ということで、その中でパフォーマンス向上に関する内容で気になった点をまとめました。

## 配列インターフェイス メソッドの非仮想化とインライン展開の機能強化

.NET 10で重点的に行ったパフォーマンス改善事項としては、脱抽象化（抽象オーバーヘッドの削減）があります。
.NET 10よりも前から、すでに脱抽象化やその派生パターンの保護付き脱抽象化（Guarded Devirtualization）といった仮想メソッドを通常メソッドに置き換えて呼び出す最適化が入っています。通常メソッドに置き換えられることでインライン展開も効くようになり、実行コストの削減ができます。とはいっても通常のアプリ開発時ではあまり気にする必要がないぐらいの小さなコストにはなります。
ただし、高パフォーマンス重視ライブラリ等を実装する際にこの小さなコストもできる限り考慮したいところです。

.NET 10ではその中の一つである配列インターフェイス メソッドの非仮想化が挙げられます。これは列挙子の作成（`GetEnumerator`）を非仮想化かつインライン化により、インターフェイス経由ではなく具体型の構造体列挙子（例：`List<T>.Enumerator`）を呼び出すことで、列挙子をヒープではなくスタック割り当てにすることができ、かつ呼び出すメソッドも仮想呼び出しではないためインライン展開も効くようになります。

例えば、`List<T>`だと、

```csharp
// List<T>.GetEnumerator
List<int> list = new List<int>();
foreach (var item in list)
{
}
```

のようなforループだと`List<T>.GetEnumerator`を呼び出して、`List<T>`用の構造体列挙子を返して列挙するため、列挙子もスタック割り当てになり、インライン展開もされています。
では、以下のような`IEnumerable<T>`にキャストした後に列挙する場合、

```csharp
// IEnumerable<T>.GetEnumerator
List<int> list = new List<int>();
IEnumerable<int> enumerable = list;
foreach (var item in enumerable)
{
}
```

`IEnumerable<T>.GetEnumerator`経由で列挙子を返すため、ヒープ割り当てになり、仮想呼び出しで呼び出すためインライン展開もされないようになります。
ベンチマークを測定すると、実行速度とメモリアロケーションで`List<T>.GetEnumerator`を呼び出すほうが良いことがわかります。

| Method                            | Job                | Toolchain | Size   | Mean      | Error     | StdDev   | Code Size | Allocated |
|---------------------------------- |------------------- |---------- |------- |----------:|----------:|---------:|----------:|----------:|
| List_T_GetEnumerator              | Benchmark.NET 9.0  | .NET 9.0  | 100000 |  32.45 μs |  4.203 μs | 0.230 μs |      42 B |         - |
| IEnumerable_T_GetEnumerator       | Benchmark.NET 9.0  | .NET 9.0  | 100000 | 113.64 μs | 14.315 μs | 0.785 μs |     401 B |      40 B |

本題の.NET 10ではどうなっているかについては、[.NET 10 ランタイムの新機能](https://learn.microsoft.com/ja-jp/dotnet/core/whats-new/dotnet-10/runtime)に記載されているSumメソッド（引数が`List<T>`と`int[]`の二種類）で、.NET 9と.NET 10でどれくらい差が発生するか確認します。

```csharp
[MemoryDiagnoser]
[DisassemblyDiagnoser(printInstructionAddresses: true, syntax: DisassemblySyntax.Masm, exportDiff: true)]
public class Benchmark
{
    private int[]? array;
    private List<int> list;

    [Params(100000)]
    public int Size { get; set; }

    [GlobalSetup]
    public void GlobalSetup()
    {
        array = Enumerable.Range(0, Size).ToArray();
        list = Enumerable.Range(0, Size).ToList();
    }

    [Benchmark]
    [MemoryRandomization]
    public void List()
    {
        Sum(list!);
    }

    [Benchmark]
    [MemoryRandomization]
    public void Array()
    {
        Sum(array!);
    }

    static int Sum(int[] array)
    {
        int sum = 0;
        IEnumerable<int> temp = array;

        foreach (var num in temp)
        {
            sum += num;
        }
        return sum;
    }

    static int Sum(List<int> array)
    {
        int sum = 0;
        IEnumerable<int> temp = array;

        foreach (var num in temp)
        {
            sum += num;
        }
        return sum;
    }

}
```

| Method | Job                | Toolchain | Size   | Mean      | Error     | StdDev   | Code Size | Allocated |
|------- |------------------- |---------- |------- |----------:|----------:|---------:|----------:|----------:|
| List   | Benchmark.NET 10.0 | .NET 10.0 | 100000 |  33.82 μs |  7.488 μs | 0.410 μs |     283 B |         - |
| Array  | Benchmark.NET 10.0 | .NET 10.0 | 100000 |  21.64 μs |  3.916 μs | 0.215 μs |      57 B |         - |
| List   | Benchmark.NET 9.0  | .NET 9.0  | 100000 | 128.81 μs | 60.675 μs | 3.326 μs |     409 B |      40 B |
| Array  | Benchmark.NET 9.0  | .NET 9.0  | 100000 |  92.61 μs | 23.758 μs | 1.302 μs |     291 B |      32 B |

ベンチマークから .NET 10では、メモリアロケーションが発生していないことから、列挙子がヒープからスタック割り当てに変更されており、またその影響でインライン展開もされているため、処理速度も向上しています。
ベンチマークで使用している`BenchmarkDotNet`では、DisassemblyDiagnoser属性を付与することでアセンブリも出力できるため、こちらも確認してみましょう。

- .NET 9（一部のみ抜粋）

```nasm
; BenchConsoleApp.Benchmark2.Sum(System.Collections.Generic.List`1<Int32>)
mov       rdi,offset MT_System.Collections.Generic.List<System.Int32>+Enumerator
mov       rcx,rdi
call      CORINFO_HELP_NEWSFAST  // ここでメモリアロケーションが発生！
mov       rdi,rax
mov       rdx,rbx
; Total bytes of code 389

; BenchConsoleApp.Benchmark2.Sum(Int32[])
lea       rbp,[rsp+50]
mov       [rbp-30],rsp
xor       ebx,ebx           // int sum = 0;
mov       r11,7FFBE4D40518  // r11にIEnumerable<T>.GetEnumeratorのアドレスを代入
call      qword ptr [r11]   // IEnumerable<T>.GetEnumeratorを実行
mov       rcx,rax           // IEnumerable<T>.GetEnumeratorを実行した戻り値を設定？
; Total bytes of code 271
```

- .NET 10（抜粋）

```nasm
; BenchConsoleApp.Benchmark2.Array()
       7FFBE7B4AAA0 push      rbp
       7FFBE7B4AAA1 sub       rsp,20
       7FFBE7B4AAA5 lea       rbp,[rsp+20]
       7FFBE7B4AAAA mov       rcx,[rcx+8]
       7FFBE7B4AAAE mov       ecx,[rcx+8]
       7FFBE7B4AAB1 xor       eax,eax
       7FFBE7B4AAB3 test      ecx,ecx
       7FFBE7B4AAB5 je        short M00_L01
       7FFBE7B4AAB7 nop       word ptr [rax+rax]
M00_L00:
       7FFBE7B4AAC0 cmp       eax,ecx
       7FFBE7B4AAC2 jae       short M00_L02
       7FFBE7B4AAC4 inc       eax
       7FFBE7B4AAC6 cmp       eax,ecx
       7FFBE7B4AAC8 jb        short M00_L00
M00_L01:
       7FFBE7B4AACA add       rsp,20
       7FFBE7B4AACE pop       rbp
       7FFBE7B4AACF ret
M00_L02:
       7FFBE7B4AAD0 mov       ecx,eax
       7FFBE7B4AAD2 call      qword ptr [7FFBE7F34A98]
       7FFBE7B4AAD8 int       3
; Total bytes of code 57
```

アセンブリについては、分かる範囲で確認すると.NET 9の場合、`List<T>`の列挙子作成時にCORINFO_HELP_NEWSFASTの呼び出しがあり、これはボックス化された値のヒープ割り当てが行われていることになります。また配列だと`IEnumerable<T>.GetEnumerator`の呼び出しでメモリアロケーションが発生しています。
それと比較し .NET 10では、`List<T>`の列挙子作成時にCORINFO_HELP_NEWSFASTの呼び出しはなく、配列もメモリアロケーションしている部分がありません。
そして両方ともSumメソッドがインライン展開されていることから、仮想呼び出しではなく通常呼び出しになっています。
ベンチマーク全体のアセンブリについては[x64アセンブリ（diffchecker.com）](https://www.diffchecker.com/5zzU2cAK/)から確認も可能ですので、気になる方はどうぞ。

## まとめ

実際にベンチマークやアセンブリ等を確認したら、色々と最適化が行われていることがわかります。
最新情報は随時収集していかないといけないですね。

## 参照URL

今回の内容を書く上で参考にしたURLについても記載しておきます。

- https://learn.microsoft.com/ja-jp/dotnet/core/whats-new/dotnet-10/runtime
- https://learn.microsoft.com/ja-jp/dotnet/core/whats-new/dotnet-9/runtime
- https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/jit/DeabstractionAndConditionalEscapeAnalysis.md
- https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/#deabstraction
- https://github.com/dotnet/runtime/issues/108988
- https://github.com/dotnet/runtime/issues/108913
- https://github.com/dotnet/runtime/issues/9028
