---
title: .NET向けハイパフォーマンスなTOMLパーサー/シリアライザー「CsToml」
url: /20250719
$namespace: Blog.Pages
$inherit: PostComponent
---

.NET8以上で使用できるハイパフォーマンスなTOMLパーサー/シリアライザーである[CsToml](https://github.com/prozolic/CsToml)のプレリリース(v1.0.0)から大体1年ほど経過しました。
その間に機能追加やバグ修正、破壊的な変更、Native AOT対応、パフォーマンス改善などの色々実施してきましたが、`CsToml`の紹介はあまりしておらず、[Qiitaで書いた記事](https://qiita.com/prozolic/items/1e4340fb84efb45ee111)で紹介したぐらいでした。
そこで、いまさらにはなりますが、`CsToml`の良い点や特徴について説明します。

- [https://github.com/prozolic/CsToml](https://github.com/prozolic/CsToml)

## そもそもTOMLとは？

まず[TOML](https://toml.io/en/)について簡単に説明すると、人が見やすく読みやすいことを目的にした設定ファイル形式になります。
基本的な形式として、キーと値のペアということで辞書に近い要素で構成されています。
`Rust`のパッケージマネージャの`Cargo`の構成ファイルとしても用いられており、こんな感じでパッケージ情報や依存ライブラリについて書かれています。

```toml
[package]
name = "irospace"
version = "0.1.0"
authors = ["prozolic <42107886+prozolic@users.noreply.github.com>"]
edition = "2021"
description = "color space and conversion method"
license = "MIT"
keywords = ["color"]
readme = "README.md"
```

似たような形式だとINIがありますが、INIには明確なフォーマットがなく使用するアプリによって色々フォーマットが存在する場合があります。
その点において、TOMLは[ABNF文法](https://github.com/toml-lang/toml/blob/1.0.0/toml.abnf)を確認することで、フォーマットやルールを確認することが可能ですので、環境によって異なるフォーマットが適用されることが少ない形式だと思っています。
ただ、TOMLの現行最新バージョン（v1.0.0）からアップデートが止まっているのが、少し気になるところではありますが...。

## .NET向けのTOMLパーサー/シリアライザーとの比較

TOMLの最新バージョン（v1.0.0）に対応している.NET向けのTOMLパーサー/シリアライザーは、
[Tomlyn](https://github.com/xoofx/Tomlyn)、[Tomlet](https://github.com/SamboyCoding/Tomlet)、[Tommy](https://github.com/dezhidki/Tommy)
などがあげられます。
その中でも、`CsToml`はパースやシリアライズ時のパフォーマンス、メモリアロケーションがこれらのライブラリよりも上回るように実装しています。
この記事を書いている時点だと、パースやシリアライズにかかる時間、メモリアロケーションの性能面で、これらのライブラリよりも上回ることができました。
上から、パース、デシリアライズ、シリアライズの順の各ライブラリとのベンチマーク結果になります。

![Parse Toml text](https://github.com/prozolic/CsToml/raw/main/img/benchmark_parse.png)
![Deserialization](https://github.com/prozolic/CsToml/raw/main/img/benchmark_deserialization.png)
![Serialization](https://github.com/prozolic/CsToml/raw/main/img/benchmark_serialization.png)

一部ケース（TOMLの値がインラインテーブルのみ）などでは、同じぐらいの速度になったりしますが、それ以外の一般的なケースでは最速かつ低アロケーションで実行することに成功しています。
あとは基本的な部分についてはNative AOT対応も行っているため、コンパイラによる警告は発生しますが、Native AOTアプリでも使用することができます。

## TOMLファイルのパース処理

`CsToml`の使い方などは、[README](https://github.com/prozolic/CsToml?tab=readme-ov-file#installation)を読んでもらえばわかりますが、
一番シンプルな使い方だとこんな感じでパースすることができます。

```csharp
var tomlText = @"
key = ""value""
number = 123
"u8;

var document = CsTomlSerializer.Deserialize<TomlDocument>(tomlText);

var key = document.RootNode["key"u8].GetString(); // key = "value"
```

他の外部ライブラリと違う特徴としては、入力値にstringではなく`ReadonlySpan<byte>`もしくは`ReadOnlySequence<byte>`を要求し、そして値を取得する際に必要なキーについても`ReadonlySpan<byte>`を使う点です。
TOMLは、UTF-8でエンコードされていますが、.NETのstringはUTF-16のため、そのままパースするとなると少し不便になります。
C#11以前だとbyte配列の言語サポートがあまり充実していないなど色々な要因からstringを使っていたと思われます。（あくまで私は推測です）

```csharp
// C#11以前
ReadOnlySpan<byte> bytes = new byte[] { (byte)'p', (byte)'r', (byte)'o', (byte)'z', (byte)'o', (byte)'l', (byte)'i', (byte)'c' };

// C#11から
ReadOnlySpan<byte> bytes2 = "prozolic"u8;
```

C#11、.NET8以降から

- UTF-8 リテラル（文字列のサフィックスに`u8`と付与するだけで`ReadonlySpan<byte>`(UTF-8)を書ける）
- [Utf8クラス](https://learn.microsoft.com/en-us/dotnet/api/system.text.unicode.utf8?view=net-9.0)の拡張(`Utf8.IsValid(ReadOnlySpan<Byte>)`、`Utf8.TryWrite`)
- [`IUtf8SpanFormattable`インターフェイス](https://learn.microsoft.com/en-us/dotnet/api/system.iutf8spanformattable?view=net-9.0)
- [`IUtf8SpanParsable<T>`インターフェイス](https://learn.microsoft.com/en-us/dotnet/api/system.iutf8spanparsable-1?view=net-9.0)

など少しずつ言語サポートも導入されており、これにより開発者側でもUTF-8を多少扱いやすくなったため、
`CsToml`では`ReadonlySpan<byte>`もしくは`ReadOnlySequence<byte>`といったUTF-8シーケンスを入力値に採用しました。
この入力値は、[SequenceReader<T>](https://learn.microsoft.com/en-us/dotnet/api/system.buffers.sequencereader-1?view=net-8.0)を`CsToml`用に調整した`Utf8SequenceReader`経由で読み取りを行っています。
`SequenceReader<T>`は、コンストラクタに`ReadonlySpan<T>`が指定できず、`ReadOnlySequence<T>`だけしか設定できないため、`Utf8SequenceReader`では`ReadonlySpan<byte>`を指定できるように調整しています。

そして、`Utf8SequenceReader`から読み取ったbyteから、キーや値を読み取っていきます。
キーや値の判定処理自体はシンプルで、先頭のbyteからTOMLの型を絞り込み、そこから専用の読み込み処理を実行しているだけ、普通です。
先頭のbyteからある程度どの型が設定されているか予想することは可能です。

例えば値の場合、以下のような必ず分かるパターンがあり、その場合必要最低限の読み込み処理のみを行うことで、処理時間を削減させます。

- `t`や`f`が来た場合、ブール型の`true`や`false`が設定されている
- `-`や`+`が来た場合、整数、浮動小数点のいずれかが設定されている
- `i`や`n`が来た場合、浮動小数点数の特殊値である`inf`や`nan`が設定されている

他の型についても考慮する必要があるため、必ず1つの型のみ絞り込むことはできませんが、それでもある程度絞り込むため、実際に

```csharp
    public TomlValue ReadValue()
    {
...
        switch(ch)
        {
            case TomlCodes.Symbol.DOUBLEQUOTED: // 文字列
                return ReadDoubleQuoteString();
            case TomlCodes.Symbol.SINGLEQUOTED: // リテラル文字列
                return ReadSingleQuoteString();
            case TomlCodes.Symbol.PLUS: // 整数または浮動小数点
            case TomlCodes.Symbol.MINUS:
                return ReadNumericValueIfLeadingSign();
            case TomlCodes.Number.Zero: // 整数または浮動小数点または時間
                return ReadNumericValueOrDateIfLeadingZero();
            case TomlCodes.Number.One: // 整数または浮動小数点または日時
            case TomlCodes.Number.Two:
            case TomlCodes.Number.Three:
            case TomlCodes.Number.Four:
            case TomlCodes.Number.Five:
            case TomlCodes.Number.Six:
            case TomlCodes.Number.Seven:
            case TomlCodes.Number.Eight:
            case TomlCodes.Number.Nine:
                return ReadNumericValueOrDate();
            case TomlCodes.Symbol.LEFTSQUAREBRACKET: // 配列
                return ReadArray();
            case TomlCodes.Alphabet.f: // ブール型の`false`
                return ReadBool(false);
            case TomlCodes.Alphabet.t: // ブール型の`true`
                return ReadBool(true);
            case TomlCodes.Alphabet.i: // 浮動小数点数の特殊値である`inf`
                return ReadDoubleInf(false);
            case TomlCodes.Alphabet.n: // 浮動小数点数の特殊値である`nan`
                return ReadDoubleNan(false);
            case TomlCodes.Symbol.LEFTBRACES: // インラインテーブル
                return ReadInlineTable();
        }

        // それ以外は不正な値とみなして例外をスロー
        ExceptionHelper.ThrowUnexpectedValueFound();
        return default!;
    }
```

と愚直に分岐処理を実装し、各分岐先での専用の読み込み・判定処理を実行しています。色々考えた結果、結局こういう愚直な分岐処理に落ち着きました。
そしてある程度どの型が読み込まれるかわかったら、そこから1byte読み取っていき値のパースを行っていきます。
その際に不正値が含まれている場合には、エラーをスローしなければなりません。
例えば、TOMLの文字列は、基本文字列、複数行基本文字列、リテラル文字列、複数行リテラル文字列、コメントも含めると5種類あります。

```toml
str  = "基本文字列"
str2 = """複数行基本文字列"""
str3 = 'リテラル文字列'
str4 = '''複数行リテラル文字列'''
```

この中で基本文字列と複数行基本文字列は、以下の文字を含むことができます。

- バックスラッシュとタブ以外の制御文字（U+0000-U+0008、U+000A-U+001F、U+007F）を除いたunicode文字
- 一部のエスケープシーケンスの短縮形
- 有効なUnicode文字（\uXXXX、\UXXXXXXX）

逆にいうと上記以外の文字が含まれている場合、不正な状態であるため、エラーをスローする必要があります。
値のように分岐処理をするのも手ですが、文字列のサイズ分だけチェック処理は行う必要があり、できる限り実行コストを低くしないとそれだけ時間がかかります。
そのため、昔から使われている手法であるルックアップテーブルを使って判定しています。

```csharp

// バックスラッシュとタブ以外の制御文字（U+0000-U+0008、U+000A-U+001F、U+007F）かどうかを判定する処理
[MethodImpl(MethodImplOptions.AggressiveInlining)]
internal static bool IsEscape(byte rawByte) // U+0000-U+0008,U+000A-U+001F,U+007F
{
    ReadOnlySpan<bool> escapeTable =
    [
        true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true,                // 0x00 - 0x0f
        true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,                 // 0x10 - 0x1f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0x20 - 0x2f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0x30 - 0x3f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0x40 - 0x4f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0x50 - 0x5f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0x60 - 0x6f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true,  // 0x70 - 0x7f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0x80 - 0x8f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0x90 - 0x9f
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0xa0 - 0xaf
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0xb0 - 0xbf
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0xc0 - 0xcf
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0xd0 - 0xdf
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0xe0 - 0xef
        false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, // 0xf0 - 0xff
    ];
    return escapeTable[rawByte];
}

// これだけ！
if (TomlCodes.IsEscape(ch))
{
    //...
}
```

これは、byteの範囲（0-255）のインデックスに判定結果を格納している配列を用いたルックアップテーブルになり、O(1)の高速判定を実現しています。
ただ配列を生成するように見えるためメモリアロケーションが発生すると思われますが、今回のようなパターンだと[performance-improvements-in-net-8](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/)によると
配列を生成しているのではなく、`ReadOnlySpan<T>`の最適化対応により実際にアロケーションが発生しません、とても良い。
他にもbyteの値を判定する処理は色々ありますが、そこでも色々なルックアップテーブルを用いて、高速判定を行っています。
まあ一部過剰に行っている部分もあるので、そこは今後の要件等を見る材料です...。

生存期間が短い処理や一時的に利用する処理などは、できる限り`ref struct`や`struct`など構造体として定義して、ヒープアロケーションが発生しないようにしています。
それ以外にも一時バッファが必要な場合には、`ArrayPool<T>.Shared`を用いた`BufferWriter`クラスを用いて、共有バッファを使いまわすなど行っています。
これらは開発当時に`neuecc`さんの[MemoryPack](https://github.com/Cysharp/MemoryPack)などハイパフォーマンスを売りにしているライブラリなどから影響を受けています。

読み取ったキーや値は、TOMLデータを格納する`TomlDocument`に追加していきます。
`TomlDocument`は、TOMLのキーと値を`Dictionary<byte[], TomlValue>`の近い形で保持するノードで構成されているツリー構造のオブジェクトです。
ノードにはほかにもTOMLテーブルのヘッダーやテーブルの配列のヘッダーかどうかの付加情報も保持しており、これによりできる限り元々のTOMLデータと同じようにシリアライズします。
実際の構成としては以下のようになっています。

![TomlDocument](./post_images/20250719_TomlDocument.svg)

ここから値を取得する際には、ルートノードの`TomlDocumentNode`からインデクサーのキーに`ReadonlySpan<byte>`を指定して取得します。
一応stringも指定できるようにしていますが、string -> byte[]の変換コストがかかるため、`ReadonlySpan<byte>`のほうが高速です。

```csharp
var document = CsTomlSerializer.Deserialize<TomlDocument>(tomlText);

var value = document.RootNode["key"u8].GetString(); // key = "value"
var value2 = document.RootNode["first"u8]["second"u8]["third"u8].GetString(); // first.second.third = "value"
```

## カスタム型のシリアライズ

カスタム型のシリアライズ時には高速かつメモリアロケーションをできる限りなくすため、Source Generatorを導入しています。
例えば以下のようなコードを書いた場合、

```csharp
[TomlSerializedObject]
public partial class TestClass
{
    [TomlValueOnSerialized]
    public int Value { get; set; }
}
```

Source Generatorによって、専用のシリアライズ処理を生成します。

```csharp
partial class TestClass : ITomlSerializedObject<TestClass>
{

    static TestClass ITomlSerializedObject<TestClass>.Deserialize(ref TomlDocumentNode rootNode, CsTomlSerializerOptions options)
    {
        var __Value__RootNode = rootNode["Value"u8];
        var __Value__ = options.Resolver.GetFormatter<int>()!.Deserialize(ref __Value__RootNode, options);

        var target = new TestClass(){
            Value = __Value__,
        };

        return target;
    }

    static void ITomlSerializedObject<TestClass>.Serialize<TBufferWriter>(ref Utf8TomlDocumentWriter<TBufferWriter> writer, TestClass target, CsTomlSerializerOptions options)
    {
        writer.BeginScope();
        writer.WriteKey("Value"u8);
        writer.WriteEqual();
        options.Resolver.GetFormatter<int>()!.Serialize(ref writer, target.Value, options);
        writer.EndKeyValue(true);
        writer.EndScope();
    }

    static void ITomlSerializedObjectRegister.Register()
    {
        if (!TomlValueFormatterResolver.IsRegistered<TestClass>())
        {
            TomlValueFormatterResolver.Register(new TomlSerializedObjectFormatter<TestClass>());
        }

        // Register Formatter in advance.

    }
}
```

あとは`CsTomlSerializer.Deserialize`を実行するだけで、デシリアライズすることができます。

```csharp
var tomlText = @"
Value = 12345
"u8;

var document = CsTomlSerializer.Deserialize<TestClass>(tomlText);
```

シリアライズ処理は、[Static abstract members](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-11.0/static-abstracts-in-interfaces)を利用した`ITomlSerializedObject<T>`インターフェイスを実装しています。
シリアライズ以外にも、使用する型のシリアライズ処理を実装した`ITomlValueFormatter<T>`インターフェイスを実装したクラスをキャッシュ（登録）する処理である`ITomlSerializedObjectRegister.Register`も生成されます。
もともとは型の`ITomlValueFormatter<T>`インターフェイスを実装したクラスがキャッシュにない場合には、リフレクションによる動的生成をした後にキャッシュする動作になっていました。
通常これで問題ないですが、Native AOTではジェネリック型の型情報が事前に分からないものはリフレクションで生成できないため、必要な型のキャッシュ処理もSource Generatorで生成することで、Native AOTアプリでも使用できるようにしています。
この設計についても、[MemoryPack](https://github.com/Cysharp/MemoryPack)の実装にかなり影響を受けています。

単に生成するだけでなく、`TomlValueOnSerialized(aliasName)`によるキー名をプロパティ名ではなく任意の名称に変更できる機能もあります。
あと細かい部分でいうと、引数なしコンストラクタ以外に条件を満たした引数ありコンストラクタもサポートしています。
条件は引数のパラメータ名とプロパティ名が一致している（大文字小文字区別なし）ことで、以下のように実装した場合には、

```csharp
[TomlSerializedObject]
internal partial class Constructor(string str) // Parameterized constructors are available.
{
    [TomlValueOnSerialized]
    public string Str { get; set; } = str;
}
```

デシリアライズ処理である`ITomlSerializedObject<Constructor>.Deserialize`で引数ありコンストラクタを使用するコードが生成されます。

```csharp
partial class Constructor : ITomlSerializedObject<Constructor>
{

    static Constructor ITomlSerializedObject<Constructor>.Deserialize(ref TomlDocumentNode rootNode, CsTomlSerializerOptions options)
    {
        var __Str__RootNode = rootNode["Str"u8];
        var __Str__ = options.Resolver.GetFormatter<string>()!.Deserialize(ref __Str__RootNode, options);

        var target = new Constructor(__Str__); // 引数ありコンストラクタを使用するコードを生成する
        return target;
    }
...
}
```

引数ありコンストラクタは、特別なものではなく普通に使われているものなので、利便性の観点からも用意しています。

[ビルトインタイプ](https://github.com/prozolic/CsToml?tab=readme-ov-file#built-in-support-type)のシリアライズ処理も、`ITomlSerializedObject<T>`インターフェイスを用いて実装しています。

```csharp
internal sealed class Int32Formatter : ITomlValueFormatter<int>
{
    public static readonly Int32Formatter Instance = new Int32Formatter();

    public int Deserialize(ref TomlDocumentNode rootNode, CsTomlSerializerOptions options)
    {
        // 現在のノードに値がない場合、デフォルトを返す。
        if (!rootNode.HasValue)
        {
            return default!;
        }

        // ノードの値がintに変換できる場合、intに変換した値を返す。
        if (rootNode.TryGetInt64(out var value))
        {
            return checked((int)value);
        }

        // ノードの値がintに変換できない場合、例外をスローする。
        ExceptionHelper.ThrowDeserializationFailed(typeof(int));
        return default;
    }

    public void Serialize<TBufferWriter>(ref Utf8TomlDocumentWriter<TBufferWriter> writer, int target, CsTomlSerializerOptions options)
        where TBufferWriter : IBufferWriter<byte>
    {
        // TOMLの数値型として書き込む
        writer.WriteInt64(target);
    }
}
```

上記は`int`のシリアライザーで、他のビルトインタイプも同様に`ITomlValueFormatter<T>`インターフェイスを実装したクラスを用意し、ジェネリック以外の型は事前にキャッシュしておくことで、デシリアライズやシリアライズ時にリフレクションを使わずに高速に処理できるようにしています。


## TOML次期バージョン（v1.1.0）の機能への対応

この記事の最初のほうに記載した通り、現時点ではTOMLの次期バージョンがいつ来るのか不明な状況ですが、
次期バージョンで追加予定機能について、オプション機能として先行利用できるようにしています。
正式リリースされていない機能を追加するのは最初は悩みましたが、[Tomlyn](https://github.com/xoofx/Tomlyn)や他言語のTOMLライブラリである[BurntSushi/toml](https://github.com/BurntSushi/toml)や[toml11](https://github.com/ToruNiina/toml11)などでも一部利用することができて、
それに単純に便利な機能（「インラインテーブルの末尾にコンマを許可する」、「インラインテーブルでの改行を許可する」など）も含まれていたため、それらのライブラリと合わせるように実装しました。
「インラインテーブルの末尾にコンマを許可する」は最新バージョンだとエラーになるため、これで何度もサンプルコードを書くときに失敗しました...。

実際に使用する際には、`CsTomlSerializerOptions.Spec`プロパティにて

```csharp
var v110Options = CsTomlSerializerOptions.Default with
{
    Spec = new ()
    {
        // 使用したい次期バージョンの機能だけ適用可能
        AllowUnicodeInBareKeys = true,
        AllowNewlinesInInlineTables = true,
        AllowTrailingCommaInInlineTables = true,
        AllowSecondsOmissionInTime = true,
        SupportsEscapeSequenceE = true,
        SupportsEscapeSequenceX = true,
    }
};
var document = CsTomlSerializer.Deserialize<TomlDocument>(tomlText, v110Options);
```

各オプション機能に対応したプロパティを設定することで、必要な機能だけ使用できるようにしています。
これは[toml11](https://github.com/ToruNiina/toml11)に影響を受けてこの形式になりました。

## テストスイート（toml-test）を用いたデシリアライズの正確性検証

TOMLパーサーとしての話をすると、当たり前ですがパースされた結果の妥当性は重要になります。
`CsToml`では、[toml-test](https://github.com/toml-lang/toml-test)で公開されている検証ファイルを用いたテストを実装しています。
テストスイート用のバイナリも公開されていますが、色々と調整したかったので、直接ファイルを扱う形にしています。
公式テストスイートがあるのはこういうテストを実装するうえでとてもありがたい限りです。

## まとめ

ちょうどこの記事を書いている間に`CsToml`のスター数が20と、私が作成したOSSの中では一番多くなりました。
他のライブラリに比べれば、大したことはないかもしれませんが、それでもこれだけの人が興味を持ってくれたのは嬉しい限りです。
ただし、まだまだ内部実装の課題やパフォーマンスの改善点はあるので、今後も少しずつ改善できていればと思います。それでは！
