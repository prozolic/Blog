---
title: 自作ライブラリのバグだと思ったら.NETランタイム（Native AOT）のバグだった話
url: /20250810
$namespace: Blog.Pages
$inherit: PostComponent
---

Native AOT対応のアプリやOSSを開発していると、時々（いやいつもかもしれませんが）、奇妙な動作に遭遇することがあります。
特にジェネリック型への対応やリフレクションの制限など、Native AOT特有の問題が発生することがあります。
これらの問題について、Source Generatorを用いたソース生成で解決できることが多いため、現行の多くのライブラリでも採用される一因になっていると思いますが、必ずしも銀の弾丸になるとは限りません。
しかも、例外情報が通常の.NETランタイムで発生するものとは異なることが多々あるので、私自身はNative AOTに対する知識はそこまで持っていないこともあって、毎回四苦八苦しながら調べて対応しています。

## 最近遭遇した事例

最近でも私が開発している[CsToml](https://github.com/prozolic/CsToml)ライブラリの開発時に遭遇しました。  
つい先日に`CsToml`のv1.7.1をリリースし、ジェネリック型のシリアライズ/デシリアライズを実行できるように修正しました。この修正はまあどちらかというと不具合に近いですが...。
これによりジェネリック型もシリアライズ/デシリアライズができるようになったため、実行確認のためNative AOTビルドでの挙動を確認していたときに見たことのないエラーが発生しました。

通常どおりジェネリック型のシリアライズを実行したときには、

```csharp
[TomlSerializedObject]
internal partial class GenericType<T>
{
    [TomlValueOnSerialized]
    public T Value { get; set; }

    [TomlValueOnSerialized]
    public T? NullableValue { get; set; }
}
```

```csharp
var genericType = new GenericType<int>()
{
    Value = 123,
    NullableValue = 456
};
using var genericTypeBytes = CsTomlSerializer.Serialize(genericType);
Console.WriteLine(genericTypeBytes.ToString());
```

Visual Studioでの出力は以下のようになり、特に問題ありませんでした。

```csharp
// Visual Studio 2022での出力
Value = 123
NullableValue = 456
```

ただし、Native AOTでビルドして実行すると、ジェネリック型のシリアライズでクラッシュするようになりました。

```csharp
Process terminated. Failed to create generic virtual method implementation

Declaring type: CsToml.Formatter.TomlSerializedObjectFormatter`1<ConsoleNativeAOT.GenericType`1<System.Int32>>
Method name: Serialize
Instantiation:
  Argument 00000000: CsToml.Utility.ArrayPoolBufferWriter`1<System.Byte>

   at System.RuntimeExceptionHelpers.FailFast(String, Exception, String, RhFailFastReason, IntPtr, IntPtr) + 0x249
   at Internal.Runtime.TypeLoader.TypeLoaderEnvironment.ResolveGenericVirtualMethodTarget(RuntimeTypeHandle, RuntimeMethodHandle) + 0x256
   at System.Runtime.TypeLoaderExports.<>c.<GVMLookupForSlotSlow>b__8_0(IntPtr, IntPtr, Object, IntPtr&) + 0x3e
   at System.Runtime.TypeLoaderExports.CacheMiss(IntPtr, IntPtr, RuntimeObjectFactory, Object) + 0x3c
   at System.Runtime.TypeLoaderExports.GVMLookupForSlotSlow(Object, RuntimeMethodHandle) + 0x68
   at System.Runtime.TypeLoaderExports.GVMLookupForSlot(Object, RuntimeMethodHandle) + 0x91
   at CsToml.CsTomlSerializer.Serialize[TBufferWriter,T](TBufferWriter&, T, CsTomlSerializerOptions) + 0xd9
   at CsToml.CsTomlSerializer.Serialize[T](T, CsTomlSerializerOptions) + 0xf7
   at Program.<Main>$(String[] args) + 0xdcf
```

スタックトレースからは、`TomlSerializedObjectFormatter<T>.Serialize`メソッドの実行に失敗していることがわかります。
`CsToml`のv1.7.1では、ジェネリック型のシリアライズメソッドも生成するようになったため、通常の.NETランタイムでは問題なく動作しますが、なぜかNative AOTでは動作しませんでした。
さらに`TomlSerializedObjectFormatter<T>.Serialize`メソッドのどこで失敗しているか確認すると、`TomlSerializedObjectFormatter<GenericType<int>>.Serialize`メソッドの呼び出しまでは成功していることが確認できました。

```csharp
public static class CsTomlSerializer
{
    public static void Serialize<TBufferWriter, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] T>(ref TBufferWriter bufferWriter, T target, CsTomlSerializerOptions? options = null)
        where TBufferWriter : IBufferWriter<byte>
    {
        options ??= DefaultOptions;
        try
        {
            var documentWriter = new Utf8TomlDocumentWriter<TBufferWriter>(ref bufferWriter);
            var formatter = GetFormatter<T>(null);
            using (formatter as IDisposable)
            {
                // ここまでは実行されている
                // TomlSerializedObjectFormatter<GenericType<int>>.Serializeメソッドを呼び出そうとして例外が発生している？
                formatter.Serialize(ref documentWriter, target, options);
            }
        }
        catch (CsTomlException cte)
        {
            throw new CsTomlSerializeException("An exception was thrown while serializing TOML. See the 'ParseExceptions' property for details about any errors.", cte);
        }
    }
}

public sealed class TomlSerializedObjectFormatter<T> : ITomlValueFormatter<T>
    where T : ITomlSerializedObject<T>
{
    public T Deserialize(ref TomlDocumentNode rootNode, CsTomlSerializerOptions options)
    {
        return T.Deserialize(ref rootNode, options);
    }

    public void Serialize<TBufferWriter>(ref Utf8TomlDocumentWriter<TBufferWriter> writer, T target, CsTomlSerializerOptions options)
        where TBufferWriter : IBufferWriter<byte>
    {
        // ここにたどり着けていない！
        T.Serialize(ref writer, target, options);
    }
}
```

この場合、ジェネリック型のシリアライズメソッドの呼び出しができていないことが原因だと考えられるため、.NETランタイム（Native AOT）のバグではないかと疑い、IssueやPull requestを調べたところ、同じような問題がすでに報告されていました。

- https://github.com/dotnet/runtime/issues/113664
- https://github.com/dotnet/runtime/pull/113684

英語が強くないので理解が間違っているかもしれませんが、静的ジェネリックメソッドのディスパッチ（どのメソッドを呼び出すかを決めること）を動的に解決する際に、期待される適切な型（closed generic types）とは異なる型（open generic types）を返すため、解決に失敗しているという内容でした。
 `CsToml`の場合、期待される適切な型（`ITomlValueFormatter<GenericType<int>>`）ではなく、実際には間違った型（`ITomlValueFormatter<GenericType<>>`で返されるためメソッドの解決に失敗していると認識しています。  
詳細が気になる人は、上記のリンクのIssueやPull requestを参照してください。
この不具合はすでに修正済みで、.NET 10では解決されています。実際に.NET 10（10.0.100-preview.6.25358.103）で試してみると、例外が発生することなく正常に動作しました。無事解決！

## その他に見つかった事例

今回の問題は[CsTomlのConsoleNativeAOTプロジェクト](https://github.com/prozolic/CsToml/tree/eba9c6c417e7b4d73425ece97c85e3c2c9cf7e9a/sandbox/ConsoleNativeAOT)で発見しましたが、実はこれ以外にも既存のコードで別の問題を見つけてしまいました。こちらは.NET 8と.NET 9では発生せず、.NET 10（10.0.100-preview.6.25358.103）で実行すると例外が発生するというものです。
こちらの問題もすでに修正されていますが、7月30日に修正されたばかりで、まだ動作確認できていない状態です。.NET 10の次のプレビューバージョンがリリースされたら、改めて確認する予定です。

- https://github.com/dotnet/runtime/issues/118072
- https://github.com/dotnet/runtime/pull/118211


## まとめ

開発時に想定外の挙動を確認した際には、多くは自分のコードが原因ですが、今回のようにランタイムのバグであるパターンもあります。
そのため、まずは自分のコードを疑い、問題が解決しない場合はランタイムのバグを疑うことが重要です。私自身に対しても言い聞かせています。
